#!/bin/bash
# =============================================================================
# ФУНКЦИИ КОНФИГУРАЦИИ
# =============================================================================

# Функция определения путей по профилю
resolve_paths_by_profile() {
    # Если указана пользовательская директория, используем её
    if [ -n "$CUSTOM_BASE_DIR" ]; then
        BASE_DIR="$CUSTOM_BASE_DIR"
        CONFIG_DIR="${BASE_DIR}/config"
        LOG_DIR="${BASE_DIR}/logs"
        if [ "$PROFILE" = "user" ]; then
            RUN_USER="${SUDO_USER:-$(whoami)}"
        else
            RUN_USER="root"
        fi
        log "Используем пользовательскую директорию: $BASE_DIR"
        return
    fi
    
    if [ "$PROFILE" = "user" ]; then
        local current_user=${SUDO_USER:-$(whoami)}
        local user_home=$(getent passwd "$current_user" | cut -d: -f6)
        
        # Определяем текущую директорию проекта
        local current_dir=$(pwd)
        local project_name=$(basename "$current_dir")
        
        # Если мы в папке с проектом, используем её
        if [ -f "bot.py" ] && [ -f "requirements.txt" ]; then
            BASE_DIR="$current_dir"
            log "Используем текущую директорию проекта: $BASE_DIR"
        else
            # Иначе используем стандартную папку
            BASE_DIR="${user_home}/bots/${project_name}"
            log "Используем стандартную директорию: $BASE_DIR"
        fi
        
        CONFIG_DIR="${BASE_DIR}/config"
        LOG_DIR="${BASE_DIR}/logs"
        RUN_USER="$current_user"
    else
        # Для prod профиля тоже проверяем текущую директорию
        local current_dir=$(pwd)
        local project_name=$(basename "$current_dir")
        
        # Если мы в папке с проектом и это не стандартная папка, используем её
        if [ -f "bot.py" ] && [ -f "requirements.txt" ] && [ "$current_dir" != "/opt/${APP_NAME}" ]; then
            BASE_DIR="$current_dir"
            CONFIG_DIR="${BASE_DIR}/config"
            LOG_DIR="${BASE_DIR}/logs"
            RUN_USER="root"  # Для prod в нестандартной папке используем root
            log "Используем текущую директорию проекта для prod: $BASE_DIR"
        else
            # Иначе используем стандартную папку
            BASE_DIR="/opt/${APP_NAME}"
            CONFIG_DIR="/etc/${APP_NAME}"
            LOG_DIR="/var/log/${APP_NAME}"
            RUN_USER="${APP_NAME}"
            log "Используем стандартную директорию для prod: $BASE_DIR"
        fi
    fi
}

# Функция загрузки существующих переменных из .env
load_existing_env() {
    if [ -f ".env" ]; then
        info "Загрузка существующих переменных из .env..."
        while IFS='=' read -r key value; do
            if [[ ! "$key" =~ ^[[:space:]]*# ]] && [[ -n "$key" ]]; then
                value=$(echo "$value" | sed 's/^"//;s/"$//')
                export "$key"="$value"
                log "Загружена переменная: $key"
            fi
        done < .env
    fi
}

# Функция обновления ключа в .env файле
update_env_key() {
    local key="$1"
    local value="$2"
    [ -f .env ] || echo "# Auto-generated by install.sh" > .env
    
    local temp_file=$(mktemp)
    
    if grep -qE "^${key}=" .env; then
        grep -v "^${key}=" .env > "$temp_file"
        echo "${key}=${value}" >> "$temp_file"
        mv "$temp_file" .env
    else
        echo "${key}=${value}" >> .env
    fi
}

# Функция установки значения по умолчанию в .env
set_env_default() {
    local key="$1"
    local value="$2"
    local interactive="${3:-false}"
    
    if grep -qE "^${key}=" .env; then
        local current
        current=$(grep -E "^${key}=" .env | sed -E "s/^${key}=//")
        if [ -z "$current" ]; then
            update_env_key "$key" "$value"
        elif [ "$interactive" = "true" ] && [ "$NON_INTERACTIVE" != "true" ]; then
            echo -e "${YELLOW}Переменная $key уже установлена: $current${NC}"
            echo -e "${CYAN}Новое значение: $value${NC}"
            echo -e "${YELLOW}Заменить? (y/N) [таймер 5 сек]:${NC} "
            if read -t 5 -n 1 response; then
                echo ""
                if [[ "$response" =~ ^[Yy]$ ]]; then
                    log "Обновляем $key: $current -> $value"
                    update_env_key "$key" "$value"
                else
                    log "Оставляем $key: $current"
                fi
            else
                echo ""
                log "Таймер истек, оставляем $key: $current"
            fi
        else
            log "Переменная $key уже установлена: $current (оставляем без изменений)"
        fi
    else
        echo "${key}=${value}" >> .env
    fi
}

# Функция создания локального .env файла
create_local_env() {
    log "Создание локального .env файла..."
    
    # Показываем существующие переменные
    check_existing_env
    
    cat > .env << EOF
# Telegram Bot Configuration
BOT_TOKEN=$BOT_TOKEN
ADMIN_IDS=$ADMIN_IDS

# Native Channels (каналы, где бот является администратором)
NATIVE_CHANNEL_IDS=-10000000000

# Database Configuration
DB_PATH=db.sqlite3

# Logging Configuration
LOG_LEVEL=INFO

# Rate Limiting Configuration
RATE_LIMIT=5
RATE_INTERVAL=60

# Optional: Custom Rate Limit Message
RATE_LIMIT_MESSAGE="⏳ Слишком часто пишешь, притормози."

# Additional Configuration
DOMAIN=$DOMAIN
EMAIL=$EMAIL
REDIS_PASSWORD=$REDIS_PASSWORD
NOTIFICATION_WEBHOOK=$NOTIFICATION_WEBHOOK
EOF

    success "Локальный .env файл создан"
}

# Функция проверки существующих переменных в .env
check_existing_env() {
    if [ -f ".env" ]; then
        info "Существующие переменные в .env:"
        echo "----------------------------------------"
        grep -E "^(BOT_TOKEN|ADMIN_IDS|DOMAIN|EMAIL|NATIVE_CHANNEL_IDS)=" .env | while IFS='=' read -r key value; do
            if [ -n "$value" ]; then
                echo "  $key: $value"
            fi
        done
        echo "----------------------------------------"
    fi
}

# Функция получения домена
get_domain() {
    if [ -n "${DOMAIN:-}" ]; then
        success "Домен: $DOMAIN (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Домен: $DOMAIN (из аргументов)"
    else
        while true; do
            echo -e "${CYAN}Введите домен для SSL сертификата (например: example.com):${NC} "
            read -r DOMAIN
            if [ -n "$DOMAIN" ] && is_valid_domain "$DOMAIN"; then
                break
            else
                error "Неверный формат домена. Попробуйте снова."
            fi
        done
    fi
}

# Функция получения email
get_email() {
    if [ -n "${EMAIL:-}" ]; then
        success "Email: $EMAIL (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Email: $EMAIL (из аргументов)"
    else
        while true; do
            echo -e "${CYAN}Введите email для Let's Encrypt (например: admin@example.com):${NC} "
            read -r EMAIL
            if [ -n "$EMAIL" ] && is_valid_email "$EMAIL"; then
                break
            else
                error "Неверный формат email. Попробуйте снова."
            fi
        done
    fi
}

# Функция получения токена бота
get_bot_token() {
    if [ -n "${BOT_TOKEN:-}" ]; then
        success "Токен бота: ${BOT_TOKEN:0:10}... (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Токен бота: ${BOT_TOKEN:0:10}... (из аргументов)"
    else
        while true; do
            echo -e "${CYAN}Введите токен Telegram бота:${NC} "
            read -r BOT_TOKEN
            if [ -n "$BOT_TOKEN" ] && is_valid_bot_token "$BOT_TOKEN"; then
                break
            else
                error "Неверный формат токена. Попробуйте снова."
            fi
        done
    fi
}

# Функция получения ID администраторов
get_admin_ids() {
    if [ -n "${ADMIN_IDS:-}" ]; then
        success "ID администраторов: $ADMIN_IDS (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "ID администраторов: $ADMIN_IDS (из аргументов)"
    else
        while true; do
            echo -e "${CYAN}Введите ID администраторов через запятую (например: 123456789,987654321):${NC} "
            read -r ADMIN_IDS
            if [ -n "$ADMIN_IDS" ]; then
                # Проверяем формат ID
                local valid=true
                IFS=',' read -ra IDS <<< "$ADMIN_IDS"
                for id in "${IDS[@]}"; do
                    if ! is_valid_telegram_id "$id"; then
                        valid=false
                        break
                    fi
                done
                if [ "$valid" = true ]; then
                    break
                else
                    error "Неверный формат ID. Используйте только цифры через запятую."
                fi
            else
                error "ID администраторов не могут быть пустыми."
            fi
        done
    fi
}

# Функция получения ссылок на каналы
get_channel_links() {
    if [ -n "${CHANNEL_LINKS:-}" ]; then
        success "Ссылки на каналы: $CHANNEL_LINKS (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Ссылки на каналы: $CHANNEL_LINKS (из аргументов)"
    else
        echo -e "${CYAN}Введите ссылки на каналы через запятую (например: @channel1, https://t.me/channel2):${NC} "
        read -r CHANNEL_LINKS
        if [ -z "$CHANNEL_LINKS" ]; then
            CHANNEL_LINKS=""
            info "Ссылки на каналы не указаны"
        fi
    fi
}

# Функция получения пароля Redis
get_redis_password() {
    if [ -n "${REDIS_PASSWORD:-}" ]; then
        success "Пароль Redis: *** (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Пароль Redis: *** (из аргументов)"
    else
        echo -e "${CYAN}Введите пароль для Redis (или нажмите Enter для автогенерации):${NC} "
        read -r REDIS_PASSWORD
        if [ -z "$REDIS_PASSWORD" ]; then
            REDIS_PASSWORD=$(generate_password 32)
            success "Сгенерирован пароль Redis: $REDIS_PASSWORD"
        fi
    fi
}

# Функция получения webhook для уведомлений
get_notification_webhook() {
    if [ -n "${NOTIFICATION_WEBHOOK:-}" ]; then
        success "Webhook уведомлений: $NOTIFICATION_WEBHOOK (из .env)"
    elif [ "$NON_INTERACTIVE" = "true" ]; then
        success "Webhook уведомлений: $NOTIFICATION_WEBHOOK (из аргументов)"
    else
        echo -e "${CYAN}Введите webhook для уведомлений (или нажмите Enter для автогенерации):${NC} "
        read -r NOTIFICATION_WEBHOOK
        if [ -z "$NOTIFICATION_WEBHOOK" ]; then
            if [ -n "$BOT_TOKEN" ] && [ -n "$ADMIN_IDS" ]; then
                local first_admin_id=$(echo "$ADMIN_IDS" | cut -d',' -f1)
                NOTIFICATION_WEBHOOK="https://api.telegram.org/bot${BOT_TOKEN}/sendMessage?chat_id=${first_admin_id}&text="
                success "Сгенерирован webhook: $NOTIFICATION_WEBHOOK"
            else
                NOTIFICATION_WEBHOOK=""
                warning "Webhook не сгенерирован (нет токена или ID админов)"
            fi
        fi
    fi
}

# Функция получения конфигурации
get_configuration() {
    info "Получение конфигурации..."
    
    # Загружаем существующие переменные
    load_existing_env
    
    # Получаем основные параметры
    get_domain
    get_email
    get_bot_token
    get_admin_ids
    get_channel_links
    get_redis_password
    get_notification_webhook
    
    # Обрабатываем каналы если указаны
    if [ -n "$CHANNEL_LINKS" ]; then
        process_channels
    fi
    
    success "Конфигурация получена"
}
